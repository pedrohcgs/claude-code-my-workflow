---
title: "Architecture Reference"
subtitle: "How the Clo-Author System Works"
---

# System Overview

Claude Code's power comes from five configuration layers that work together:

| Layer | Location | Loaded When |
|-------|----------|-------------|
| **CLAUDE.md** | Project root | Every session |
| **Rules** | `.claude/rules/` | Always-on or path-scoped |
| **Skills** | `.claude/skills/` | On demand (slash commands) |
| **Agents** | `.claude/agents/` | On demand (via skills or orchestrator) |
| **Hooks** | `.claude/settings.json` | On events (automatic) |

Claude reliably follows about **100--150 custom instructions**. Your system prompt uses ~50, leaving ~100 for your project. CLAUDE.md and always-on rules share this budget. Path-scoped rules, skills, and agents load on demand.

---

# CLAUDE.md --- The Project Constitution

`CLAUDE.md` is the single most important file. Claude reads it at the start of every session. It should be a **slim constitution** --- short directives and pointers, not comprehensive documentation. Aim for ~120 lines:

- **Core principles** --- 5--6 bullets (plan-first, verify-after, quality gates, worker-critic pairs, LEARN tags)
- **Folder structure** --- where everything lives
- **Commands** --- compilation, deployment
- **Skill quick reference** --- table of available slash commands
- **Customization tables** --- Beamer environments, notation
- **Current state** --- what's done, what's in progress

::: {.callout-important}
## Keep It Lean

If CLAUDE.md exceeds ~150 lines, Claude starts ignoring rules silently. Put detailed standards in path-scoped rules instead.
:::

---

# Rules --- Auto-Loading Domain Knowledge

Rules are markdown files in `.claude/rules/` that Claude loads automatically. The key design principle is **path-scoping**: rules with a `paths:` YAML frontmatter only load when Claude works on matching files.

## Always-On Rules

Always-on rules (no `paths:` frontmatter) load every session:

| Rule | Purpose |
|------|---------|
| `plan-first-workflow.md` | Plan before you build |
| `orchestrator-protocol.md` | Dependency-driven contractor mode loop |
| `session-logging.md` | Three logging triggers |
| `session-reporting.md` | Consolidated session report |
| `adversarial-pairing.md` | Every worker has a critic |
| `separation-of-powers.md` | Critics never create, creators never critique |
| `three-strikes.md` | Max 3 rounds, then escalate |
| `severity-gradient.md` | Critic severity by phase |
| `dependency-graph.md` | Phases by dependency, not sequence |
| `scoring-protocol.md` | Weighted aggregation formula |
| `standalone-access.md` | Any skill works outside the pipeline |
| `revision-protocol.md` | R&R cycle routing |
| `research-journal.md` | Auto-append journal after agent reports |
| `meta-governance.md` | Template vs working project |
| `domain-profile.md` | Field-specific calibration |

## Path-Scoped Rules

Path-scoped rules load only when relevant:

| Rule | Triggers On |
|------|------------|
| `quality-gates.md` | `.tex`, `.R`, `.do`, `.py`, `.jl` |
| `single-source-of-truth.md` | `Figures/`, `.tex` |
| `pdf-processing.md` | `master_supporting_docs/` |
| `table-generator.md` | `Tables/`, `.R` |
| `exploration-folder-protocol.md` | `explorations/` |
| `exploration-fast-track.md` | `explorations/` |

---

# Agents --- Worker-Critic Pairs

The v3 architecture uses **adversarial worker-critic pairs**. Every creator has a paired critic. Critics produce reports but never edit files. Creators implement but never score themselves.

## The 6 Worker-Critic Pairs

| Worker (Creates) | Critic (Reviews) | Phase |
|-----------------|-----------------|-------|
| **Librarian** --- literature collector | **Editor** --- coverage critic, journal editor | Discovery |
| **Strategist** --- identification design | **Econometrician** --- 4-phase causal audit | Strategy |
| **Coder** --- implements analysis | **Debugger** --- 12-category code review | Execution |
| **Writer** --- drafts paper + humanizer | **Proofreader** --- 6-category manuscript review | Paper |
| **Storyteller** --- creates Beamer talks | **Discussant** --- 5-category talk review | Presentation |
| **Referee** (x2) --- blind peer review | **Editor** --- editorial decision | Peer Review |

## Additional Agents

| Agent | Role |
|-------|------|
| **Explorer** | Data finder (paired with Surveyor critic) |
| **Surveyor** | Data quality critic |
| **Verifier** | Infrastructure: compilation, execution, AEA compliance |
| **Orchestrator** | Infrastructure: dispatch, escalation, rule enforcement |

## All 15 Agents

| Agent | File | Purpose |
|-------|------|---------|
| Librarian | `librarian.md` | Literature collection + proximity scoring |
| Editor | `editor.md` | Evolving critic (lit → paper → journal editor) |
| Explorer | `explorer.md` | Data source finder + feasibility scoring |
| Surveyor | `surveyor.md` | Data quality critic |
| Strategist | `strategist.md` | Identification strategy + PAP mode |
| Econometrician | `econometrician.md` | 4-phase causal inference audit |
| Coder | `coder.md` | Analysis implementation (R/Stata/Python/Julia) |
| Debugger | `debugger.md` | 12-category code review |
| Writer | `writer.md` | Paper drafting + humanizer pass |
| Proofreader | `proofreader.md` | 6-category manuscript review |
| Referee | `referee.md` | Blind peer review (x2 instances) |
| Storyteller | `storyteller.md` | Beamer talk creation (4 formats) |
| Discussant | `discussant.md` | Talk critic (advisory scoring) |
| Verifier | `verifier.md` | Standard (4 checks) + submission (10 checks) |
| Orchestrator | `orchestrator.md` | Agent dispatch + escalation routing |

## Multi-Model Strategy

Not all agents need the same model. Each agent file has a `model:` field:

| Task Type | Recommended Model | Why |
|-----------|-------------------|-----|
| Complex analysis | `model: opus` | Needs deep reasoning |
| Fast, constrained work | `model: sonnet` | Speed matters more |
| Default | `model: inherit` | Uses main session model |

---

# Skills --- Reusable Slash Commands

Skills are multi-step workflows invoked with `/command`. Each skill lives in `.claude/skills/[name]/SKILL.md` and dispatches the appropriate v3 agents.

Skills can be invoked two ways: **explicitly** (you type `/proofread Paper/main.tex`) or **automatically** (Claude invokes them when relevant). Most of the time, you just describe what you want.

See the [User Guide](user-guide.qmd#all-skills-reference) for the complete skills table.

---

# Hooks --- Automated Enforcement

Hooks live in `.claude/settings.json` and fire on events, regardless of context state.

## Design Principles

- Use **command-based hooks** for fast, mechanical checks
- Use **rules** for nuanced judgment
- Avoid prompt-based hooks that trigger LLM calls on every response

## All 7 Hooks

| Hook | Event | What It Does |
|------|-------|-------------|
| Session log reminder | `Stop` | Reminds about session logs |
| Desktop notification | `Notification` | macOS alert when Claude needs attention |
| File protection | `PreToolUse` | Blocks edits to bibliography and settings |
| Context state capture | `PreCompact` | Saves plan state + context survival checklist |
| Context restoration | `SessionStart[compact\|resume]` | Restores context after compaction |
| Context monitor | `PostToolUse[Bash\|Task]` | Progressive warnings at 40%/55%/65%/80%/90% |
| Verification reminder | `PostToolUse[Write\|Edit]` | Reminds to compile/render (`.tex`, `.R`, `.do`, `.py`, `.jl`) |

---

# Memory System

Four persistent layers plus ephemeral conversation:

| Layer | File | Updated When | Purpose |
|-------|------|--------------|---------|
| Project context | `CLAUDE.md` | Rarely | Project rules, folder structure |
| Corrections | `MEMORY.md` | On `[LEARN]` tag | Prevent repeating mistakes |
| Task strategy | `quality_reports/plans/` | Once per task | Plan survives handoff |
| Decision reasoning | `quality_reports/session_logs/` | Incrementally | Record *why* decisions were made |
| Conversation | Context window | Every response | Current working memory (**not** persistent) |

---

# Context Survival System

When context compaction happens, two hooks preserve and restore state:

```
Session running → context fills up → PreCompact fires
                                           ↓
                                    pre-compact.py saves:
                                    • Active plan path
                                    • Current task
                                    • Recent decisions
                                    • Context survival checklist
                                           ↓
                                    Auto-compaction happens
                                           ↓
                                    SessionStart(compact|resume) fires
                                           ↓
                                    post-compact-restore.py:
                                    • Reads saved state
                                    • Prints context summary
                                    • Claude knows where it left off
```

### Context Monitoring

The `context-monitor.py` hook tracks approximate context usage:

| Threshold | Message | Purpose |
|-----------|---------|---------|
| 40%, 55%, 65% | Suggest `/learn` | Capture discoveries before compaction |
| 80% | Info message | Auto-compact approaching |
| 90% | Caution | Complete current task with full quality |

---

# The Orchestrator (Contractor Mode) {#sec-orchestrator}

Once a plan is approved, the orchestrator takes over autonomously, dispatching agents based on the **dependency graph**.

## The Mental Model

Think of the orchestrator as a **general contractor**. You are the client. You describe what you want. The plan-first protocol is the blueprint phase. Once you approve the blueprint, the contractor takes over: hires the right specialists (agents), inspects their work (verification), sends them back to fix issues (review-fix loop), and only calls you when the job passes inspection (quality gates).

## Dependency-Driven Dispatch

```
Phase 1: Discovery (no dependencies)
  ├── Librarian → Editor (lit review)
  └── Explorer → Surveyor (data assessment)
          ↓
Phase 2: Strategy (depends on Discovery)
  └── Strategist → Econometrician (strategy memo)
          ↓
Phase 3: Execution (depends on Strategy)
  ├── Coder → Debugger (analysis scripts)
  └── Writer → Proofreader (paper sections)
          ↓
Phase 4: Peer Review (depends on Execution)
  ├── Referee x2 → Editor (editorial decision)
  └── paper-excellence (weighted aggregate)
          ↓
Phase 5: Submission (depends on Peer Review, score >= 95)
  └── Verifier (10-check AEA audit)
```

Phases activate when dependencies are met, not by forced sequence. Parallel dispatch within phases (e.g., Librarian and Explorer run simultaneously in Phase 1).

## The Loop

```
Plan approved → orchestrator activates
  │
  Step 1: IMPLEMENT — Execute plan steps
  │
  Step 2: VERIFY — Compile, render, check outputs
  │         If verification fails → fix → re-verify
  │
  Step 3: REVIEW — Run worker-critic pairs
  │
  Step 4: FIX — Apply fixes (critical → major → minor)
  │         Max 3 rounds per pair (three-strikes rule)
  │
  Step 5: RE-VERIFY — Confirm fixes are clean
  │
  Step 6: SCORE — Weighted aggregate per scoring-protocol
  │
  └── Score >= threshold?
        YES → Present summary to user
        NO  → Loop to Step 3 (max 5 total rounds)
              After max → present with remaining issues
```

### Three-Strikes Escalation

If a worker-critic pair can't resolve after 3 rounds:

| Pair | Escalation Target |
|------|------------------|
| Coder + Debugger | → Strategist (design may be wrong) |
| Writer + Proofreader | → Editor (framing may need rethinking) |
| Strategist + Econometrician | → User (fundamental design disagreement) |
| Storyteller + Discussant | → Writer (paper content may need revision) |

### "Just Do It" Mode

When you say "just do it", the orchestrator still runs the full verify-review-fix loop, but skips the final approval pause and auto-commits if the score is >= 80.

---

# Plan-First Workflow {#sec-plan-first}

For any non-trivial task, Claude enters plan mode before writing code.

## The Protocol

```
Non-trivial task arrives
  │
  Step 1: Enter Plan Mode
  Step 2: Draft plan (approach, files, verification)
  Step 3: Save to quality_reports/plans/YYYY-MM-DD_description.md
  Step 4: Present plan to user
  Step 5: User approves (or revises)
  Step 6: Save initial session log
  Step 7: Orchestrator takes over (dependency-driven dispatch)
  Step 8: Update session log + plan status to COMPLETED
```

Plans are saved to disk so they survive context compression. The rule: **avoid `/clear`** --- prefer auto-compression.

## Session Logging (3 Triggers)

1. **After plan approval** --- create the log with goal, plan summary, rationale
2. **During implementation** --- append 1--3 lines as design decisions happen
3. **At session end** --- add what was accomplished, open questions, unresolved issues

---

# The Adversarial Pattern

The single most powerful pattern in the system: **worker + critic**.

```
+------------------+
|    Worker         |  "I created the analysis."
|    (READ-WRITE)   |
+--------+---------+
         |
    +----v----+
    | Critic  |  "I found 8 issues. 2 Critical."
    | (READ   |
    | ONLY)   |
    +----+----+
     /       \
APPROVED   NEEDS WORK
    |          |
  Done    +----v---------+
          |    Worker     |  "Fixed 8/8 issues."
          |    (Round 2)  |
          +----+---------+
               |
          +----v----------+
          |    Critic      |  "Re-audit: 1 remaining."
          |    (Round 2)   |
          +----+----------+
               |
          ... (up to 3 rounds, then escalate)
```

**Why it works:** The critic can't fix files (read-only), so it has no incentive to downplay issues. The worker can't approve itself (the critic re-audits). This prevents Claude from saying "looks good" about its own work.

**Severity gradient:** Critics calibrate harshness by phase --- encouraging in Discovery, precise in Execution, adversarial in Peer Review.

---

# Parallel Agents

Claude Code can spawn **multiple agents simultaneously** using the Task tool.

## When to Use

| Scenario | Sequential (slow) | Parallel (fast) |
|----------|-------------------|-----------------|
| Paper excellence review | Run each agent sequentially | Run Econometrician + Debugger + Proofreader + Verifier simultaneously |
| Literature search | Search one database at a time | Spawn agents for journals, NBER, SSRN |
| Data exploration | Check one source at a time | Spawn agents for each data category |

The orchestrator recognizes independent subtasks and spawns parallel agents automatically.

## Practical Limits

- **3--4 agents** is the sweet spot. More increases overhead without proportional speedup.
- Agents are **independent** --- they cannot see each other's work. Dependent tasks run sequentially.
- Parallel agents multiply token usage.

---

# Scoring Protocol

The weighted aggregate score determines quality gate passage:

| Component | Weight | Agent(s) |
|-----------|--------|----------|
| Literature | 10% | Librarian + Editor |
| Data | 10% | Explorer + Surveyor |
| Identification | 25% | Econometrician |
| Code | 15% | Debugger |
| Paper | 25% | Proofreader |
| Polish | 10% | Proofreader (writing subscore) |
| Replication | 5% | Verifier |

**Missing components:** If a component hasn't been scored (e.g., no literature review yet), its weight is redistributed proportionally across available components.

**Submission gate:** Aggregate >= 95 AND every individual component >= 80.

---

# Domain Profile

The domain profile (`.claude/rules/domain-profile.md`) calibrates all agents to a specific research field. It can be populated two ways:

1. **`/interview-me`** --- generates it automatically from the research interview
2. **Manual editing** --- fill in the template directly

All agents read this file for:

- Target journal tiers (for Editor and Referee)
- Common data sources (for Explorer)
- Identification strategies (for Strategist and Econometrician)
- Field conventions (for Coder and Writer)
- Seminal references (for Librarian)
- Referee concerns (for Econometrician and Referee)

---

# Additional Workflows: Slides & Lectures {#additional-workflows-slides-lectures}

The Clo-Author inherits a lecture production pipeline from [its origin](https://github.com/pedrohcgs/claude-code-my-workflow). These workflows are available for users who also produce course materials.

## Creating Talks from Papers

The `/create-talk` skill dispatches the Storyteller (creator) and Discussant (critic) to generate Beamer presentations in 4 formats (job market, seminar, short, lightning). All content derives from `Paper/main.tex`.

## Replication-First Coding

When working with papers that have replication packages:

```
Phase 1: Inventory original code → record "gold standard" numbers
Phase 2: Translate (e.g., Stata → R) → match original spec EXACTLY
Phase 3: Verify match → tolerance < 0.01 for estimates, < 0.05 for SEs
Phase 4: Only then extend with new estimators and specifications
```

## Branch Isolation with Git Worktrees

Git worktrees create a separate working directory linked to the same repository. Useful for major translations, risky refactors, or multi-day projects.

| Situation | Use Worktree? |
|-----------|---------------|
| Quick fix to one file | No |
| Major refactor | Yes |
| Experimenting with new approach | Yes |

For most users, working directly on main with frequent commits is simpler and sufficient.

---

# Constitutional Governance (Optional) {#sec-constitutional}

As your project grows, some decisions become non-negotiable. The `templates/constitutional-governance.md` template helps you distinguish between:

- **Immutable principles** (Articles I--V): Non-negotiable rules
- **User preferences**: Flexible patterns that can vary

Use it **after** you've established 3--7 recurring patterns.
